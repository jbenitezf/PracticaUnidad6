/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package clases;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.InputStream;
import java.io.PrintStream;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer.MethodName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.thoughtworks.qdox.JavaDocBuilder;
import com.thoughtworks.qdox.model.JavaSource;

import clases.helpers.Aleatorios;
import clases.helpers.MyReflection;

/**
 * Esta clase esta preparada para testear el programa main principal de un
 * proyecto interceptando y suplantando tando la entrada como la salida estandar
 * teclado y pantalla
 * 
 * @author eserrano
 *
 */
@TestMethodOrder(MethodName.class)
class MainTest {

	private static final String DATEPATTERN = "dd/MM/yyyy";
	private static final String DELIMITER = ">";
	private final PrintStream standardOut = System.out;
	private final InputStream standardIn = System.in;
	private final ByteArrayOutputStream outputStreamCaptor = new ByteArrayOutputStream();

	@BeforeEach
	void setUp() {
		System.setOut(new PrintStream(outputStreamCaptor));
	}

	@Test
	@DisplayName("Compilación")
	/**
	 * Compila y se pueden establecer reglas basicas, Por ejemplo impedir la
	 * importación de ciertas clases
	 */
	void test00RequisitosBasicos() {
		assertTrue(true);
	}

	@Test
	@DisplayName("Clase Perfil usuario")
	/**
	 * toString
	 */
	void test01UserProfile() throws Exception {
		prohibidoArrayList();
		String className = UserProfile.class.getName();

		//Pruebas de Forma
		pruebasForma(className);
		
		//Pruebas de Fondo
		pruebasFondo(className);
		
	}
	
	@Test
	@DisplayName("Main - Alta de Lista")
	/**
	 * toString
	 */
	void test02AltaLista() throws Exception {
		prohibidoArrayList();

		print("Main - Alta de lista");
		List<UserProfile> lista = new LinkedList<UserProfile>();
		List<UserProfile> lista2 = creaUsuariosAleatorios();
		
		for(int i=0;i<lista2.size();i++) {			
			UserProfile userProfile = lista2.get(i);
			String entrada = toStringPattern(lista2.get(i));
			
			Main.alta(lista, entrada);
			
			assertEquals(i+1, lista.size());
			assertEquals(userProfile, lista.get(i));
		}
		
		assertEquals(lista2.size(),lista.size());
		assertTrue(lista.containsAll(lista2));
		
	}
	
	String toStringPattern(UserProfile u) throws Exception {

		String className=UserProfile.class.getName();
		LocalDate expectedDate = (LocalDate) MyReflection.ejecutaMetodo(u, className,
				"getRegDate", null);
		String expectedStringDate = expectedDate.format(
				DateTimeFormatter.ofPattern(DATEPATTERN));
		
		Float expectedRating = (Float) MyReflection.ejecutaMetodo(u, className,
				"getRating", null);
		String expectedNick = (String) MyReflection.ejecutaMetodo(u, className,
				"getNick", null);
		
		return expectedNick + DELIMITER
				+ expectedStringDate + DELIMITER
				+ expectedRating;
	}
	
	@Test
	@DisplayName("Main - Baja de Lista")
	/**
	 * toString
	 */
	void test03BajaLista() throws Exception {
		prohibidoArrayList();
		print("Main - Baja de lista");
		//Prepara datos de prueba
		List<UserProfile> lista = creaUsuariosAleatorios();
		UserProfile [] usuarios = lista.toArray(new UserProfile[0]);
		//Elige uno para eliminar 
		int pos = Aleatorios.numeroAleatorio(0, lista.size()-1);
		assertTrue(Main.baja(lista, usuarios[pos]));
		assertEquals(usuarios.length-1,lista.size());
		assertFalse(Main.baja(lista, usuarios[pos]));
		
	}
	
	@Test
	@DisplayName("Main - Salvar Lista a Fichero")
	/**
	 * toString
	 */
	void test04SalvarLista() throws Exception {
		prohibidoArrayList();

		print("Main - Baja de lista");
		
		//Prepara datos de prueba
		List<UserProfile> lista = creaUsuariosAleatorios();
		String [] lineas = getListInputStringFormat(lista);
		
		//Introduce el nombre de fichero para que lo lea el programador
		String nombreFichero = Aleatorios.cadenaAleatoria(5, 5);
		setIn(nombreFichero + "\n");
		Main.salvarDatos(lista);
		
		//Comprueba el fichero creado por el programa
		File fichero = new File(nombreFichero);
		assertTrue(fichero.exists());
		Scanner myReader = new Scanner(fichero);
	    int i = 0;
	    while (myReader.hasNextLine())
	     assertEquals(lineas[i++], myReader.nextLine());
	    	 	     
	    myReader.close();
	    assertEquals(lineas.length, i);
	    //Limpia el escenario
	    assertTrue(fichero.delete());
		
	}
	
	@Test
	@DisplayName("Main - Cargar Lista de Fichero")
	/**
	 * toString
	 */
	void test05CargarLista() throws Exception {
		prohibidoArrayList();

		print("Main - Baja de lista");
		
		//Preparamos datos de  prueba
		List<UserProfile> lista = creaUsuariosAleatorios();
		String [] lineas = getListInputStringFormat(lista);
		
		//Creamos el fichero a leer con los datos de prueba
		String nombreFichero = Aleatorios.cadenaAleatoria(5, 5);
		FileWriter fs = new FileWriter(nombreFichero);
		
		for(int i=0;i<lineas.length;i++) 	
			fs.write(lineas[i]+"\n");
			
		fs.close();
		
		//Creamos una nueva lista
		List<UserProfile> lista2 = new LinkedList<UserProfile>();
		setIn(nombreFichero);
		Main.cargarDatos(lista2);
		assertEquals(lista.size(),lista2.size());
		assertTrue(lista2.containsAll(lista));
		assertEquals(lista,lista2);
	     
		//Limpiamos el escenario
		File fic = new File(nombreFichero);
		assertTrue(fic.exists());
		assertTrue(fic.delete());		
	}
	
	@Test
	@DisplayName("UserProfile - Orden Natural")
	/**
	 * toString
	 */
	void test06OrdenNaturalUserProfile() throws Exception {
		prohibidoArrayList();
		print("Comprobando Orden Natural de User Profile");

		String className = UserProfile.class.getName();
		assertTrue(MyReflection.implementsInterface(className, 
				"java.lang.Comparable"));
		
		String nick1 = "adela";
		String nick2 = "antonia";
		
		LocalDate fecha1 = Aleatorios.fecha(
				Aleatorios.numeroAleatorio(2018, 2018));
		LocalDate fecha2 = Aleatorios.fecha(
				Aleatorios.numeroAleatorio(2019, 2019));
		
		UserProfile u1 = creaUsuario(nick1, fecha1, 0f);
		UserProfile u2 = creaUsuario(nick2, fecha1, 0f);
		

		print("Orden Natural nick");
		ordenNick(className, u1, u2);
		
		print("Orden Natural desempate Fecha");
		UserProfile u3 = creaUsuario(nick2, fecha2, 0f);
		ordenNick(className, u2, u3);	
	}
	
	void ordenNick(String className, UserProfile u1, UserProfile u2) throws Exception{
		int result = (int) MyReflection.ejecutaMetodo(u1, className, "compareTo",
				Arrays.asList(u2).toArray(), Object.class);
		assertTrue(result<0);
		
		result = (int) MyReflection.ejecutaMetodo(u2, className, "compareTo",
				Arrays.asList(u1).toArray(), Object.class);
		assertTrue(result>0);
		
		result = (int) MyReflection.ejecutaMetodo(u1, className, "compareTo",
				Arrays.asList(u1).toArray(), Object.class);
		assertEquals(result,0);
	}
	
	@Test
	@DisplayName("Main - Ordenamiento Natural")
	/**
	 * toString
	 */
	void test07OrdenamientoNatural() throws Exception {
		prohibidoArrayList();
		print("Main - Ordenamiento natural");
		
		//Preparamos datos de  prueba
		LinkedList<UserProfile> lista = (LinkedList<UserProfile>)creaUsuariosAleatorios();
		@SuppressWarnings("unchecked")
		LinkedList<UserProfile> lista2 = (LinkedList<UserProfile>)lista.clone();
		@SuppressWarnings("unchecked")
		LinkedList<UserProfile> lista3 = (LinkedList<UserProfile>)lista.clone();
		
		Collections.sort((List)lista);
		Main.ordena(lista2);
		assertEquals(lista.size(), lista2.size());
		assertEquals(lista, lista2);
		assertNotEquals(lista2, lista3);
	}
	
	@Test
	@DisplayName("UserProfile - Orden Adicional Rating")
	/**
	 * toString
	 */
	void test08OrdenAdicionalUserProfile() throws Exception {
		prohibidoArrayList();
		print("Comprobando Orden Adicional Rating de User Profile");

		String className = UserProfile.class.getName();
		assertTrue(MyReflection.implementsInterface(className, 
				"java.util.Comparator"));
		
		UserProfile u1 = creaUsuario("a", LocalDate.now(), 2.1f);
		UserProfile u2 = creaUsuario("a", LocalDate.now(), 2.2f);
		UserProfile u3 = creaUsuario("a", LocalDate.now(), 2.2f);
		
		ordenRating(className, u1, u2);
		int result = (int) MyReflection.ejecutaMetodo(u3, className, "compare",
				Arrays.asList(u3,u2).toArray(), Object.class, Object.class);
		assertEquals(0,result);
	}
	
	@Test
	@DisplayName("Main - Ordenamiento por Rating")
	/**
	 * toString
	 */
	void test09OrdenamientoRating() throws Exception {
		prohibidoArrayList();
		print("Main - Ordenamiento natural");

		String className = UserProfile.class.getName();
		//Preparamos datos de  prueba
		LinkedList<UserProfile> lista = (LinkedList<UserProfile>)creaUsuariosAleatorios();
		@SuppressWarnings("unchecked")
		LinkedList<UserProfile> lista2 = (LinkedList<UserProfile>)lista.clone();
		@SuppressWarnings("unchecked")
		LinkedList<UserProfile> lista3 = (LinkedList<UserProfile>)lista.clone();
		
		Collections.sort(lista,getComp(className));
		Main.ordenaRating(lista2);
		assertEquals(lista.size(), lista2.size());
		assertEquals(lista, lista2);
		assertNotEquals(lista2, lista3);
	}
	
	Comparator<UserProfile> getComp(String className) {
		return new Comparator<UserProfile>() {
			public int compare(UserProfile o1, UserProfile o2) {
				Float r1,r2;
				try {
					r1 = (Float) MyReflection.ejecutaMetodo(o1,
							className, "getRating",null);
					r2 = (Float) MyReflection.ejecutaMetodo(o2,
							className, "getRating",null);
				} catch (Exception e) {
					throw new RuntimeException("Error recuperando datos");
				}
				return r1.compareTo(r2);
			}
		};
	}
	

	void ordenRating(String className, UserProfile u1, UserProfile u2) throws Exception{
		int result = (int) MyReflection.ejecutaMetodo(u1, className, "compare",
				Arrays.asList(u1,u2).toArray(), Object.class, Object.class);
		assertTrue(result<0);
		
		result = (int) MyReflection.ejecutaMetodo(u2, className, "compare",
				Arrays.asList(u2,u1).toArray(), Object.class, Object.class);
		assertTrue(result>0);
		
		result = (int) MyReflection.ejecutaMetodo(u1, className, "compare",
				Arrays.asList(u1,u1).toArray(), Object.class, Object.class);
		assertEquals(result,0);
	}
	
	private List<UserProfile> creaUsuariosAleatorios() throws Exception{
		String className = UserProfile.class.getName();
		
		int max = Aleatorios.numeroAleatorio(10, 20);
		
		List<UserProfile> lista = new LinkedList<UserProfile>();
		
		for(int i=0;i<max;i++) {
			LocalDate expectedDate = Aleatorios.fecha(
					Aleatorios.numeroAleatorio(2010, 2050));
			Float expectedRating = Aleatorios.numeroAleatorio(0f, 5f);
			String expectedNick = Aleatorios.cadenaAleatoria(8, 15);
			

			
			
			Object [] initialValues = new Object[] {
					expectedNick,expectedDate,expectedRating};
			Object userProfile = MyReflection.invocaConstructor(className,
					initialValues,String.class,LocalDate.class,Float.class);

			lista.add((UserProfile)userProfile);
		}
		
		return lista;
	}
	
	private UserProfile creaUsuario(String expectedNick, 
			LocalDate expectedDate, Float expectedRating) throws Exception{
		String className = UserProfile.class.getName();
		
		Object [] initialValues = new Object[] {
				expectedNick,expectedDate,expectedRating};
		Object userProfile = MyReflection.invocaConstructor(className,
			initialValues,String.class,LocalDate.class,Float.class);

		
		return (UserProfile) userProfile;
	}
	
	private String[] getListInputStringFormat(List<UserProfile> lista) throws Exception{
		
		int i=0;
		String [] resultado = new String[lista.size()];
		for (UserProfile userProfile : lista)
			resultado[i++]=toStringPattern(userProfile);
				
		return resultado;
	}
	
	private void setIn(String entrada) {
		System.setIn(new ByteArrayInputStream(entrada.getBytes()));
	}

	@AfterEach
	void tearDown() {
		System.setOut(standardOut);
		System.setIn(standardIn);
	}
	
	void pruebasForma(String className) throws Exception {
		print("Probando constructor por defecto");
		constructorDefecto(className);	

		print("Probando constructor sobrecargado");
		constructorSobrecargado(className);
				
		print("Probando que solo hay dos constructores");
		assertEquals(2, MyReflection.cuentaConstructores(className));
				
		print("Probando existencia Atributos");
		compruebaAtributos(className);
		
		print("Probando existencia Metodos");
		compruebaExistenciaMetodos(className);
	}
	
	void pruebasFondo(String className)throws Exception {
		print("Constructor Sobrecargado y getters");
		pruebaConstructorSobrecargadoGetters(className);
		
		print("Constructor por Defecto y setters");
		pruebaConstructorDefaultSetters(className);
		
		print("MetodoEquals");
		pruebaEquals(className);
	}
	
	void pruebaEquals(String className) throws Exception{
		LocalDate expectedDate = Aleatorios.fecha(2021);
		Float expectedRating = Aleatorios.numeroAleatorio(0f, 5f);
		String expectedNick = Aleatorios.cadenaAleatoria(8, 15);
		
		print("True si es el mismo objeto");
		Object [] initialValues = new Object[] {
				expectedNick,expectedDate,expectedRating};
		Object userProfile = MyReflection.invocaConstructor(className,
				initialValues,String.class,LocalDate.class,Float.class);
		
		Boolean eq = (Boolean) MyReflection.ejecutaMetodo(userProfile,
				className, "equals", 
				Arrays.asList(userProfile).toArray(),
				Object.class);
		assertTrue(eq);
		
		print("No distingue entre mayusculas y minusculas");
		expectedNick=expectedNick.toLowerCase();
		char caracter = Character.toUpperCase(expectedNick.charAt(0));
		expectedNick.replace(expectedNick.charAt(0), caracter);
		Object [] initialValues2 = new Object[] {
				expectedNick,expectedDate,expectedRating};
		Object userProfile2 = MyReflection.invocaConstructor(className,
				initialValues2,String.class,LocalDate.class,Float.class);
		
		eq = (Boolean) MyReflection.ejecutaMetodo(userProfile2,
				className, "equals", 
				Arrays.asList(userProfile).toArray(),
				Object.class);
		assertTrue(eq);
		
		print("Da distinto en otros casos");
		expectedNick=expectedNick+"a";
		Object [] initialValues3 = new Object[] {
				expectedNick,expectedDate,expectedRating};
		Object userProfile3 = MyReflection.invocaConstructor(className,
				initialValues3,String.class,LocalDate.class,Float.class);
		
		eq = (Boolean) MyReflection.ejecutaMetodo(userProfile3,
				className, "equals", 
				Arrays.asList(userProfile2).toArray(),
				Object.class);
		assertFalse(eq);
		
	}
	
	void  pruebaConstructorSobrecargadoGetters(String className) throws Exception{
		
		LocalDate expectedDate = Aleatorios.fecha(2020);
		Float expectedRating = Aleatorios.numeroAleatorio(0f, 5f);
		String expectedNick = Aleatorios.cadenaAleatoria(8, 15);
		
		Object [] initialValues = new Object[] {
				expectedNick,expectedDate,expectedRating};
		Object userProfile = MyReflection.invocaConstructor(className,
				initialValues,String.class,LocalDate.class,Float.class);
		
		String actualnick = (String) MyReflection.ejecutaMetodo(userProfile,
				className, "getNick", null);
		assertEquals(expectedNick,actualnick);
		
		LocalDate fecha = (LocalDate)MyReflection.ejecutaMetodo(
				userProfile, className, "getRegDate",
				null);
		assertEquals(expectedDate, fecha);
		
		Float actualRating = (Float)MyReflection.ejecutaMetodo(
				userProfile, className, "getRating",
				null);
		assertEquals(expectedRating, actualRating);
	}
	
	void  pruebaConstructorDefaultSetters(String className) throws Exception{
		LocalDate expectedDate = Aleatorios.fecha(2019);
		Float expectedRating = Aleatorios.numeroAleatorio(0f, 5f);
		String expectedNick = Aleatorios.cadenaAleatoria(8, 15);
		Object userProfile = MyReflection.invocaConstructor(className);
		
		//Prueba de Nick
		MyReflection.ejecutaMetodo(userProfile, className, "setNick",
				Arrays.asList(expectedNick).toArray(), String.class);
		String actualNick = (String) MyReflection.ejecutaMetodo(userProfile, className, "getNick",
				null);
		assertEquals(expectedNick,actualNick);
		

		//Prueba de regDate
		MyReflection.ejecutaMetodo(userProfile, className, "setRegDate",
				Arrays.asList(expectedDate).toArray(), LocalDate.class);
		LocalDate actualDate = (LocalDate)MyReflection.ejecutaMetodo(
				userProfile, className, "getRegDate",
				null);
		assertEquals(expectedDate, actualDate);
		

		//Prueba de rating
		MyReflection.ejecutaMetodo(userProfile, className, "setRating",
				Arrays.asList(expectedRating).toArray(), Float.class);
		Float actualRating = (Float)MyReflection.ejecutaMetodo(
				userProfile, className, "getRating",
				null);
		assertEquals(expectedRating, actualRating);
	}
	
	
	
	void constructorDefecto(String className) throws Exception {
		Object object = MyReflection.invocaConstructor(className);
		assertNotNull(object, "No creado");
	}
	

	void constructorSobrecargado(String className) throws Exception {
		Object [] initialValues = new Object[] {"Yuri",LocalDate.now(),5.0f};
		Object object = MyReflection.invocaConstructor(className,initialValues,String.class,LocalDate.class,Float.class);
		assertNotNull(object, "No creado");
	}
	
	void compruebaAtributos(String className) throws Exception {
		
		String [][] atributos = {
				{"nick","String"},
				{"regDate","LocalDate"},
				{"rating","Float"}
		};
		
		for (String[] atributo : atributos) {
			assertEquals(atributo[1], MyReflection.getField(className, atributo[0]));
		}
		
	}
	
	void compruebaExistenciaMetodos(String className) throws ClassNotFoundException {
		List<String> expectedMethods = Arrays
				.asList("setNick","getNick",
						"setRegDate","getRegDate",
						"setRating","getRating",
						"equals");
		
		List<String> actualMethods = MyReflection.getPublicMethods(className);
		assertTrue(actualMethods.containsAll(expectedMethods));
	}

	void prohibidoArrayList() {
		String fileFullPath = "src/main/java/clases/Main.java";
		compruebaProhibido(fileFullPath, "ArrayList");
		compruebaProhibido(fileFullPath, "LinkedList");
	}

	void compruebaProhibido(String classFullPath, String classForbidden) {
		JavaDocBuilder builder = new JavaDocBuilder();
		try {
			builder.addSource(new FileReader(classFullPath));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			assertTrue(false);
		}

		JavaSource src = builder.getSources()[0];
		String[] imports = src.getImports();

		for (String imp : imports) {
			if (imp.endsWith("." + classForbidden)) {
				print("Prohibido importar " + classForbidden + " en la clase " + classFullPath);
				assertTrue(false);
			}
			if (imp.endsWith(".*")) {
				print("Prohibido importar con .*" + " en la clase " + classFullPath);
				assertTrue(false);
			}
		}

		String sc = src.getCodeBlock();

		Pattern pattern = Pattern.compile(classForbidden + "\\.");
		Matcher matcher = pattern.matcher(sc);
		if (matcher.find()) {
			print("Prohibido referenciar " + classForbidden + " en la clase " + classFullPath);
			assertTrue(false);
		}
	}

	void print(Object message) {
		this.standardOut.println(message);
	}

}